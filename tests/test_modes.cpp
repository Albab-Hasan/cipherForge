#include "cf/aes.hpp"
#include "cf/modes.hpp"

#include <gtest/gtest.h>
#include <array>
#include <vector>

TEST(BlockModes, ECBEncryptDecrypt)
{
  constexpr std::array<uint8_t, 32> key = {
      0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
      0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
      0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
      0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4};

  const std::vector<uint8_t> plaintext = {'T', 'h', 'e', ' ', 'q', 'u', 'i', 'c', 'k', ' ', 'b', 'r', 'o', 'w', 'n', ' ', 'f', 'o', 'x', ' ', '1', '3'}; // 23 bytes

  cf::AES256 aes{std::span<const uint8_t, 32>(key)};

  auto ciphertext = cf::ecb_encrypt(aes, plaintext);
  auto decrypted = cf::ecb_decrypt(aes, ciphertext);

  EXPECT_EQ(plaintext, decrypted);
}

TEST(BlockModes, CBCEncryptDecrypt)
{
  constexpr std::array<uint8_t, 32> key = {
      0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
      0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
      0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
      0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4};

  constexpr std::array<uint8_t, 16> iv = {
      0x00, 0x01, 0x02, 0x03,
      0x04, 0x05, 0x06, 0x07,
      0x08, 0x09, 0x0a, 0x0b,
      0x0c, 0x0d, 0x0e, 0x0f};

  const std::vector<uint8_t> plaintext = {'L', 'a', 'z', 'y', ' ', 'd', 'o', 'g', ' ', '4', '2'}; // 11 bytes

  cf::AES256 aes{std::span<const uint8_t, 32>(key)};

  auto ciphertext = cf::cbc_encrypt(aes, iv, plaintext);
  auto decrypted = cf::cbc_decrypt(aes, iv, ciphertext);

  EXPECT_EQ(plaintext, decrypted);
}

TEST(BlockModes, ECBEncryptDecryptEmptyInput)
{
  constexpr std::array<uint8_t, 32> key = {
      0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
      0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
      0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
      0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4};

  const std::vector<uint8_t> plaintext = {}; // Empty input

  cf::AES256 aes{std::span<const uint8_t, 32>(key)};

  auto ciphertext = cf::ecb_encrypt(aes, plaintext);
  auto decrypted = cf::ecb_decrypt(aes, ciphertext);

  EXPECT_TRUE(decrypted.empty());
}

TEST(BlockModes, ECBEncryptDecryptLongInput)
{
  constexpr std::array<uint8_t, 32> key = {
      0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
      0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
      0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
      0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4};

  std::vector<uint8_t> plaintext(1024, 'A'); // 1KB of data

  cf::AES256 aes{std::span<const uint8_t, 32>(key)};

  auto ciphertext = cf::ecb_encrypt(aes, plaintext);
  auto decrypted = cf::ecb_decrypt(aes, ciphertext);

  EXPECT_EQ(plaintext, decrypted);
}

TEST(BlockModes, CBCEncryptDecryptEmptyInput)
{
  constexpr std::array<uint8_t, 32> key = {
      0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
      0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
      0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
      0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4};

  constexpr std::array<uint8_t, 16> iv = {
      0x00, 0x01, 0x02, 0x03,
      0x04, 0x05, 0x06, 0x07,
      0x08, 0x09, 0x0a, 0x0b,
      0x0c, 0x0d, 0x0e, 0x0f};

  const std::vector<uint8_t> plaintext = {}; // Empty input

  cf::AES256 aes{std::span<const uint8_t, 32>(key)};

  auto ciphertext = cf::cbc_encrypt(aes, iv, plaintext);
  auto decrypted = cf::cbc_decrypt(aes, iv, ciphertext);

  EXPECT_TRUE(decrypted.empty());
}

TEST(BlockModes, CBCEncryptDecryptLongInput)
{
  constexpr std::array<uint8_t, 32> key = {
      0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
      0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
      0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
      0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4};

  constexpr std::array<uint8_t, 16> iv = {
      0x00, 0x01, 0x02, 0x03,
      0x04, 0x05, 0x06, 0x07,
      0x08, 0x09, 0x0a, 0x0b,
      0x0c, 0x0d, 0x0e, 0x0f};

  std::vector<uint8_t> plaintext(1024, 'B'); // 1KB of data

  cf::AES256 aes{std::span<const uint8_t, 32>(key)};

  auto ciphertext = cf::cbc_encrypt(aes, iv, plaintext);
  auto decrypted = cf::cbc_decrypt(aes, iv, ciphertext);

  EXPECT_EQ(plaintext, decrypted);
}

TEST(BlockModes, ECBDecryptInvalidInput)
{
  constexpr std::array<uint8_t, 32> key = {
      0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
      0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
      0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
      0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4};

  // Ciphertext not multiple of block size
  const std::vector<uint8_t> ciphertext = {0x01, 0x02, 0x03, 0x04, 0x05};

  cf::AES256 aes{std::span<const uint8_t, 32>(key)};

  EXPECT_THROW(
      {
        cf::ecb_decrypt(aes, ciphertext);
      },
      std::runtime_error);
}

TEST(BlockModes, CBCDecryptInvalidInput)
{
  constexpr std::array<uint8_t, 32> key = {
      0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
      0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
      0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
      0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4};

  constexpr std::array<uint8_t, 16> iv = {
      0x00, 0x01, 0x02, 0x03,
      0x04, 0x05, 0x06, 0x07,
      0x08, 0x09, 0x0a, 0x0b,
      0x0c, 0x0d, 0x0e, 0x0f};

  // Ciphertext not multiple of block size
  const std::vector<uint8_t> ciphertext = {0x01, 0x02, 0x03, 0x04, 0x05};

  cf::AES256 aes{std::span<const uint8_t, 32>(key)};

  EXPECT_THROW(
      {
        cf::cbc_decrypt(aes, iv, ciphertext);
      },
      std::runtime_error);
}

TEST(BlockModes, PaddingTest)
{
  // Test various input lengths to ensure correct PKCS#7 padding
  const std::vector<std::vector<uint8_t>> test_inputs = {
      {'A'},                                                                                // 1 byte
      {'A', 'B', 'C', 'D', 'E', 'F', 'G'},                                                  // 7 bytes
      {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P'},     // 16 bytes
      {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q'} // 17 bytes
  };

  constexpr std::array<uint8_t, 32> key = {
      0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
      0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
      0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
      0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4};

  cf::AES256 aes{std::span<const uint8_t, 32>(key)};

  for (const auto &input : test_inputs)
  {
    auto ciphertext = cf::ecb_encrypt(aes, input);
    auto decrypted = cf::ecb_decrypt(aes, ciphertext);

    EXPECT_EQ(input, decrypted);
  }
}
